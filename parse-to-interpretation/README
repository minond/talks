**From parsing to interpretation: let's build a language**

An understanding of program evaluation can be a truly enlightening thing for a
programmer. By breaking down the process to its essence and implementing the
parsing and interpretation steps for a Lisp, we will explore both the
interesting and oddly simple algorithms employed in making a language.

Our Lisp will have familiar characteristics like variables, higher-order
functions, conditionals, and lexical scope.


Outline:

- Topic introduction
  - What is this talk about?
  - Who is this talk for?
  - What are we building?
  - What is an interpreter?
  - What does our language look like?
  - Why does our language look the way it does?
- What are languages?
- Why one might care about languages?
- What one might get out of learning about languages?
- Overview of an interpreter
- Tokenizer
  - Tokenizer generators
- Parser
  - BNF/EBNF
  - Parser generators
  - Top down parsers
  - Recursive descent parsers
- Evaluator
  - Pattern matching in Scala


Assets:

- Computer image: https://pixabay.com/en/cartoon-computer-tooned-in-2026805/
- Google search image: https://www.google.com/search?q=define+interpreter


Resources:

- https://en.wikipedia.org/wiki/Extended_Backus-Naur_form
- https://en.wikipedia.org/wiki/Abstract_syntax_tree
- https://en.wikipedia.org/wiki/Recursive_descent_parser
- https://en.wikipedia.org/wiki/Multi-pass_compiler
